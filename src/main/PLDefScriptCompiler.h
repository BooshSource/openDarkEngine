/******************************************************************************
 *
 *    This file is part of openDarkEngine project
 *    Copyright (C) 2005-2007 openDarkEngine team
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 * http://www.gnu.org/copyleft/lesser.txt.
 *****************************************************************************/
 
#ifndef __PLDEFSCRIPTCOMPILER_H
#define __PLDEFSCRIPTCOMPILER_H

#include <OgreCompiler2Pass.h>
#include <OgreDataStream.h>
#include <stack>
#include "DTypeDef.h"
#include "DVariant.h"

#include "BinaryService.h"
#include "LinkService.h"
#include "PropertyService.h"

namespace Opde {

	/** Property and link definitions script compiler.
	* Compiles link (Relation) and property definition scripts, and registers the property and relation definitions to the appropriate classes.
	* These scripts define various aspects of Link/Property behaviour
	*/
	class PLDefScriptCompiler : public Ogre::Compiler2Pass {
		public:
			/** Compiler */
			PLDefScriptCompiler(void);
			
			/** Destructor */
			~PLDefScriptCompiler(void);
			
			/** gets BNF Grammer for dtype script.
			*/
			const Ogre::String& getClientBNFGrammer(void) const { return pldefScript_BNF; }

			/** get the name of the BNF grammar.
			*/
			virtual const Ogre::String& getClientGrammerName(void) const { static const Ogre::String grammerName("PLDef Script"); return grammerName; }
			
			/** Parses the script and fills the BinaryService */
			void parseScript(Ogre::DataStreamPtr& stream, const Ogre::String& groupName) {
				Compiler2Pass::compile(stream->getAsString(),  stream->getName());
			}
			
			/** Returns the position usable for autogenerated tokens to use - ogre's requirement */
			virtual size_t getAutoTokenIDStart() const;

	protected:
		// Token ID enumeration
		enum TokenID {
			ID_UNKOWN = 0, 
			ID_OPENBRACE, ID_CLOSEBRACE, // { and }
			
			ID_RELATION,
			ID_PROPERTY,
			ID_DTYPE,
			ID_FAKESIZE,
			ID_HIDDEN,
			ID_NO_DATA,
			ID_D_VER, // link data chunk version
			ID_L_VER, // link chunk version
			ID_REL_VER, // Relations chunk version  
			ID_P_VER,
			ID_LABEL,
			ID_INHERIT,
			ID_AUTOTOKEN // The start of the autogenerated tokens
		};
	
		/** ID of the current structure */
		enum CompileStateID {
			/// Unknown position
			CS_UNKNOWN = 0, 
			/// In relation
			CS_RELATION,
			/// In property
			CS_PROPERTY
		};
		
		/** Compilation state. The position the compilation is in, together with some information about the context. */
		typedef struct CompileState {
			CompileStateID state;
			
			Ogre::String name;
			Ogre::String label;
			Ogre::String dtypename;
			Ogre::String inherit;
			
			// TODO: If query cache is implemented, and selection of such is possible, implement query cache record and registration
			bool hidden;
			bool no_data;
			int fake_size;
			
			uint dmajor;
			uint dminor;
			
			uint lmajor;
			uint lminor;
			
			uint pmajor;
			uint pminor;
		};
		
		/// The current state
		CompileState mCurrentState;
		
		/// BinaryService the compiler uses to find dtypes
		BinaryServicePtr mBinaryService;
		
		/// Link service filled with relation definitions
		LinkServicePtr mLinkService;
		
		/// Property service filled with property definitions
		PropertyServicePtr mPropertyService;
		
		/** Get the data length from TokenID */
		int getDataLenFromID(TokenID id);
				
		/** get the typedef from binary service. First the given namespace's, then the global if not found in namespace */
		DTypeDefPtr getTypeDef(const std::string& group, const std::string& name);
		
		/** Dispatches the type definition according to the current state */
		void dispatchType(DTypeDefPtr def);

		/** Expects, and reads the number of elements in the [] parenthesis. Returns the parsed number */
		int parseBoxBrace();
		
		/// static library database for tokens and BNF rules
		static TokenRule pldefScript_RulePath[];
		
		/// simplified Backus - Naur Form (BNF) grammer for the dtype script
		static Ogre::String pldefScript_BNF;

		/// CallBack funcition type
		typedef void (PLDefScriptCompiler::* PLDS_Action)(void);
		
		/// Map of token ID->method callback
		typedef std::map<size_t, PLDS_Action> TokenActionMap;
		
		/// Iterator over TokenActionMap
		typedef TokenActionMap::iterator TokenActionIterator;
		
		/** Feed the compiler with the token definitions */
        	virtual void setupTokenDefinitions(void);
		
		/** Register a token, with possible action if not NULL */
		void addLexemeTokenAction(const Ogre::String& lexeme, const size_t token, const PLDS_Action action = 0);
		
		/** Execute the action given the token ID */
		void executeTokenAction(const size_t tokenID);
		
		/** If something goes wrong, this method is called */
		void logParseError(const Ogre::String& error);
		
		/** Map of Token value as key to an Action.  An Action converts tokens into
		    the final format.
		    All instances use the same Token Action Map.
		*/
		static TokenActionMap mTokenActionMap;
		
		// Default versions for link and data chunks, and for property chunks too 
		uint mDefaultLMajor;
		uint mDefaultLMinor;
		uint mDefaultDMajor;
		uint mDefaultDMinor;
		uint mDefaultPMajor;
		uint mDefaultPMinor;
		
		// ---------- Parsing methods -----------------------
		/// Parses a Opening Curly Brace
		void parseOpenBrace(void);
		
		/// Parses a Closing Curly Brace
		void parseCloseBrace(void);
		
		/// Parses a relation definition
		void parseRelation(void);
		
		/// Parses a property definition
		void parseProperty(void);
		
		/// Parses a dtype name definition
		void parseDType(void);
		
		/// Parses fake size definition
		void parseFakeSize(void);
				
		/// Parses hidden definition
		void parseHidden(void);
		
		/// Parses no_data flag
		void parseNoData(void);
		
		/// Parses the chunk version info
		void parseVersion(void);
		
		/// Parses a label definition
		void parseLabel(void);
		
		/// Parses a inheritor definition
		void parseInherit(void);
	};
}

#endif

