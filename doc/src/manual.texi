\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename manual.info
@settitle OpenDarkEngine Developer's Manual
@c %**end of header

@copying
This manual is for openDarkEngine (version @value{VERSION}, @value{UPDATED})

Copyright @copyright{} 2005-2006 OpenDarkEngine team.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom.''
@end quotation
@end copying

@titlepage
@title Sample Title
    
@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
     
@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top
@top OpenDarkEngine Developer's Manual
     
This is the main developer's manual for OpenDarkEngine
@end ifnottex
     
@menu
* Introduction::      Introduction to the manual
* Core architecture:: The core architecture of the engine
* Services::          The available services
@c Not used roght now - * Index::             Complete index.
@end menu


@c --------------------------------------------------------------------
@node Introduction
@chapter Introduction

You have just started reading the developers manual for OpenDarkEngine project. The aim of this document is
to give you some insight about the project's architecture, enable you to quickly orient in the project's source
code.

@section Used technologies
The core of OpenDarkEngine written in C++, various other parts are planned or already written in python. Build system
used is CMake. Libraries currently used are OGRE, FreeImage.

@c --------------------------------------------------------------------
@node Core architecture
@chapter Core architecture

Whole engine exists in the Opde namespace. That means that every class definition, as well as typedef or enumeration,
all these things are defined within the Opde namespace, and either prefixed with 'Opde::', or imported via using keyword
when referenced from outside of this namespace.

Throughout the source code, some of the instances are held in memory - their lifetime is controled - by shared_ptr class.
This class is very simmilar to the Boost's shared_ptr. The instances held by this smart pointer wrapper are easily identified
thanks to the typedefs used to distribute them - all those types are postfixed with 'Ptr' string (e.g. 'ServicePtr').

@heading Core classes

These are the core classes used:
@table @asis
@item Opde::Root
	A central class for the engine. Manages the engines lifetime.
@item Opde::ServiceManager
	Manages the Service objects.
@item Opde::Service
	Subclasses of which fulfil various purposes (Graphics, AI, Sound, Physics, Object System, etc.)
@end table

@heading Root object
Is a bed for the whole engine. Exposes various initialization methods, logging methods. Whole engine is constructed
and initialized using this class.

@heading ServiceManager
As the name of it suggests, this class is used to hold services and manage them. Each subclass of the Service class has a
Factory class instance registered here (Opde::Root object does this).

Service manager also manages the bootstrap/main lifetime stages of the engine existence.

@heading Service
The whole engine is built around a modular concept of Services. Services are autonomous classes that serve different 
purposes. All service instances are managed using a ServiceManager object. Each of the service's instance exists only 
once within ServiceManager's ownership. Services reference, use each other. For this to work well, shared pointers are
used to reference services. 

Each of the services has a name and service mask. Name is used to reference the service, mask is used to automate some common
tasks, and to mask the instantinated services, as requested via the parameter to the Opde::Root constructor. The service mask
also enables one to construct, for example, only the core object system of the engine, meaning no graphical output, no simulation
is done. This is especially usable for tool makers.

All services are constructed using Service Factories, which are registered by either client code or Opde::Root object
within the bootstrapping phase of the engine.

There are three stages of service's life time:
@table @asis
@item Bootstrap phase
	Which is used to setup resources for the services and initialize service's dependencies. 
	This phase is active when the engine is bootstrapping.
@item Main lifetime
	Which represents the phase of the lifetime service is fully usable.
@item Shutdown
	Which is used to break circular references between services and release all the resources service holds.
@end table

All services are guaranteed to be bootstrapped and shut down under the condition of a normal application flow.

@c --------------------------------------------------------------------
@node Services
@chapter Services

This is the current list of available engines services:

@table @asis
@item Binary
	Is a helper service that holds dynamically defined types and enumerations, as specified by, for example the dtdef scripts.
@item Database
	Is a game database loading/saving service. Manages the loading/saving of .GAM/.MIS/.SAV files. All the services which store some
	data inside these files listen to the events that this service generates and act accordingly.
@item Object
	Is the main service for the engines object system. Manages game object's lifetime.
@item Link
	Is the link management service. Stores Relation objects. Each relation object stores all links of particular flavor.
@item Property
	Is the property manager. Properties are named "types" that object can carry. Each of the property types has one PropertyGroup instance held by this service.
@item Inherit
	This service manages object trait inheritance. Currently is used to cache and propagate inherited properties for objects.
@item WorldRep
	This service is responsible for loading and preparing the World Rep, which is a different name for the level geometry. It loads and prepares it for display.
@item Light
	This service manages lights in the world
@item Material
	Helper service that helps with game object materials (textures, etc).
@item Render
	This service manages the display of the engine.
@end table


@c --------------------------------------------------------------------
@node Index
@unnumbered Index
   
@printindex cp
     
@bye
